# Asincron√≠a

La asincron√≠a es uno de los pilares fundamentales de Javascript, ya que es un lenguaje de programaci√≥n
de un s√≥lo subproceso o hilo (single thread), lo que significa que s√≥lo puede ejecutar una cosa a la vez.

Si bien los idiomas de un s√≥lo hilo simplifican la escritura de c√≥digo porque no tiene que preocuparse 
por los problemas de concurrencia, esto tambi√©n significa que no puede realizar operaciones largas como 
el acceso a la red sin bloquear el hilo principal.

Imagina que solicitas datos de una API. Dependiendo de la situaci√≥n, el servidor puede tardar un tiempo 
en procesar la solicitud mientras bloquea el hilo principal y hace que la p√°gina web no responda.

Ah√≠ es donde entra en juego la asincron√≠a que permite realizar largas solicitudes de red sin bloquear el hilo principal.

JavaScript fue dise√±ado para ser ejecutado en navegadores, trabajar con peticiones sobre la red y procesar 
las interacciones de usuario, al tiempo que mantiene una interfaz fluida.

Javascript usa un modelo as√≠ncrono y no bloqueante, con un loop de eventos implementado en un s√≥lo hilo, 
(single thread) para operaciones de entrada y salida (input/output).

Gracias a esta soluci√≥n, Javascript es √°ltamente concurrente a pesar de emplear un s√≥lo hilo.

---
Antes de explicar como funciona el modelo de JavaScript es importante entender algunos conceptos:

Procesamiento Single thread (Hilo √∫nico) y Multi thread (Hilos m√∫ltples).
Operaciones de CPU y Operaciones de I/O (Entrada y Salida).
Operaciones Concurrentes y Paralelas.
Operaciones Bloqueantes y No Bloqueantes.
Operaciones S√≠ncronas y As√≠ncronas.

## Single thread y Multi thread

Un hilo la unidad b√°sica de ejecuci√≥n de un proceso, cada que abres un programa como el navegador o tu editor
de c√≥digo, se levanta un proceso en tu computadora e internamente este puede tener uno o varios hilos (threads) 
ejecut√°ndose para que el proceso funcione.

## Operaciones de CPU y de Entrada y Salida

* Operaciones CPU: Aquellas que pasan el mayor tiempo consumiendo Procesos del CPU, por ejemplo, la escritura de ficheros.
* Operaciones de Entrada y Salida: Aquellas que pasan la mayor parte del tiempo esperando la respuesta de una 
petici√≥n o recurso, como la solicitud a una API o BD.

## Concurrencia y Paralelismo

* Concurrencia: cuando dos o m√°s tareas progresan simult√°neamente, pero en realidad se turnan para 
usar los recursos del sistema.
* Paralelismo: cuando dos o m√°s tareas se ejecutan, al mismo tiempo en diferentes n√∫cleos de CPU o hilos.

**Resumen**:
- ‚úÖ Concurrencia = Alternancia r√°pida entre tareas (aunque solo una se ejecuta a la vez).
- ‚úÖ Paralelismo = Ejecuci√≥n simult√°nea de m√∫ltiples tareas en diferentes procesadores.

## Bloqueante y No Bloqueante

Se refiere a como la fase de espera de las operaciones afectan a nuestra aplicaci√≥n:

* ***Bloqueante***: Son operaciones que no devuelven el control a nuestra aplicaci√≥n hasta que se ha completado. 
Por tanto el thread queda bloqueado en estado de espera.
* ***No Bloqueante***: Son operaciones que devuelven inmediatamente el control a nuestra aplicaci√≥n, independientemente
del resultado de esta. En caso de que se haya completado, devolver√° los datos solicitados. En caso contrario 
(si la operaci√≥n no ha podido ser satisfecha) podr√≠a devolver un c√≥digo de error.

## S√≠ncrono y As√≠ncrono
Se refiere a ¬øcu√°ndo tendr√° lugar la respuesta?:

S√≠ncrono: La respuesta sucede en el presente, una operaci√≥n s√≠ncrona esperar√° el resultado.
As√≠ncrono: La respuesta sucede a futuro, una operaci√≥n as√≠ncrona no esperar√° el resultado.

Con lo anterior en JavaScript podemos tener:

C√≥digo s√≠ncrono y bloqueante o
C√≥digo as√≠ncrono y no bloquenate

## JavaScript S√≠ncrono

Cada operaci√≥n se hace de una vez, bloqueando el flujo de ejecuci√≥n, el hilo es bloqueado mientras espera la respuesta, 
cuando esta se procesa pasa a la siguiente operaci√≥n y as√≠ sucesivamente al terminar todas las operaciones.

## JavaScript As√≠ncrono

Cada operaci√≥n se ejecuta y devuelve inmediatamente el control al hilo, evitando el bloqueo, cuando cada operaci√≥n termine 
se enviar√° una notificaci√≥n de que ha terminado, es entonces cuando la respuesta se encolar√° para ser procesada.

---

## Mecanismos as√≠ncronos en JavaScript

Para controlar la asincron√≠a, JavaScript cuenta con algunos mecanismos:

* Callbacks.
* Promises.
* Async / Await.

### Callbacks

Una callback (llamada de vuelta) es una funci√≥n que se ejecutar√° despu√©s de que otra lo haga.

Es un mecanismo para asegurar que cierto c√≥digo no se ejecute hasta que otro haya terminado.

Al ser JavaScript un lenguaje orientado a eventos, las callbacks son una buena t√©cnica para controlar la as√≠ncron√≠a,

La diferencia entre Call Stack y Callback Queue en JavaScript es clave para entender su modelo de concurrencia. 
Te lo explico de manera clara:

**Call Stack (Pila de llamadas)**:
Es una estructura LIFO (Last In, First Out) donde se almacenan las funciones que se est√°n ejecutando en ese momento.
Cuando una funci√≥n es llamada, se apila en el Call Stack. Cuando termina, se desapila.
Si una funci√≥n llama a otra, la segunda se apila encima de la primera.

**Callback Queue (Cola de callbacks)**:
Es una lista de tareas que esperan ser ejecutadas cuando el Call Stack est√© vac√≠o.
Aqu√≠ van los callbacks de tareas as√≠ncronas, como setTimeout, eventos del DOM o peticiones HTTP (fetch).
El Event Loop se encarga de mover los callbacks desde la Callback Queue al Call Stack cuando este √∫ltimo est√° vac√≠o.

**Resumen r√°pido**:
- ‚úÖ Call Stack ‚Üí Ejecuta funciones sincr√≥nicas inmediatamente.
- ‚úÖ Callback Queue ‚Üí Guarda tareas as√≠ncronas para ejecutarlas despu√©s.

### Promises

Una promesa es un objeto que representa el resultado de una operaci√≥n as√≠ncrona y tiene 3 estados posibles:

* Pendiente.
* Resuelta.
* Rechazada.

Tienen la particularidad de que se pueden encadenar (then), siendo el resultado de una promesa, los datos de 
entrada de otra posible funci√≥n.

Las promesas mantienen un c√≥digo m√°s legible y mantenible que las callbacks, adem√°s tienen un mecanismo para 
la detecci√≥n de errores (catch) que es posible usar en cualquier parte del flujo de datos.

### Async Await

Las promesas fueron una gran mejora respecto a las callbacks para controlar la asincron√≠a en JavaScript, sin 
embargo pueden llegar a ser muy verbosas a medida que se requieran m√°s y m√°s m√©todos .then().

Las funciones as√≠ncronas (async / await) surgen para simplificar el manejo de las promesas.

La palabra async declara una funci√≥n como as√≠ncrona e indica que una promesa ser√° autom√°ticamente devuelta.

Podemos declarar como async funciones con nombre, an√≥nimas o funciones flecha.

La palabra await debe ser usado siempre dentro de una funci√≥n declarada como async y esperar√° de forma 
as√≠ncrona y no bloqueante a que una promesa se resuelva o rechace.

```js
function cuadradoPromise(value) {
  if (typeof value !== "number") {
    return Promise.reject(
      `Error, el valor " ${value} " ingresado no es un n√∫mero`
    );
  }

  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({
        value,
        result: value * value,
      });
    }, 0 | (Math.random() * 1000));
  });
}

async function funcionAsincronaDeclarada() {
  try {
    console.log("Inicio Async Function");

    let obj = await cuadradoPromise(0);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise(1);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise(2);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise("3");
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise(4);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise(5);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    console.log("Fin Async Function");
  } catch (err) {
    console.error(err);
  }
}

funcionAsincronaDeclarada();

const funcionAsincronaExpresada = async () => {
  try {
    console.log("Inicio Async Function");

    let obj = await cuadradoPromise(6);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise(7);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise(8);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise("9");
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    obj = await cuadradoPromise(10);
    console.log(`Async Function: ${obj.value}, ${obj.result}`);

    console.log("Fin Async Function");
  } catch (err) {
    console.error(err);
  }
};

funcionAsincronaExpresada();
```

---

# JSON

JSON (JavaScript Object Notation) es un formato ligero para intercambiar datos. Se basa en la sintaxis 
de los objetos de JavaScript, pero se usa ampliamente en distintos lenguajes de programaci√≥n.

## üìå ¬øPara qu√© sirve JSON en JavaScript?

JSON se usa principalmente para:
- ‚úÖ Enviar y recibir datos entre un servidor y un cliente (ejemplo: una API).
- ‚úÖ Almacenar configuraciones o informaci√≥n estructurada.
- ‚úÖ Compartir datos entre diferentes aplicaciones.

## üöÄ C√≥mo trabajar con JSON en JavaScript

1Ô∏è‚É£ Estructura de JSON
JSON est√° basado en pares clave-valor y usa:
- ‚úîÔ∏è Llaves {} para objetos
- ‚úîÔ∏è Corchetes [] para listas o arreglos

```js
{
  "nombre": "Juan",
  "edad": 25,
  "esEstudiante": true,
  "cursos": ["JavaScript", "HTML", "CSS"]
}
```

## 2Ô∏è‚É£ Convertir JSON a un objeto en JavaScript

Cuando recibimos un JSON en formato de texto (por ejemplo, desde una API), necesitamos 
convertirlo a un objeto para manipularlo en JavaScript. Para esto usamos JSON.parse().

```js
const jsonString = '{"nombre": "Juan", "edad": 25}';
const objetoJS = JSON.parse(jsonString); // Convierte JSON a objeto JavaScript

console.log(objetoJS.nombre); // "Juan"
console.log(objetoJS.edad);   // 25
```

## 3Ô∏è‚É£ Convertir un objeto de JavaScript a JSON

Si queremos enviar datos a un servidor, a menudo necesitamos convertir un objeto 
JavaScript a formato JSON. Para esto usamos JSON.stringify().

```js
const persona = {
  nombre: "Mar√≠a",
  edad: 30,
  ciudad: "Madrid"
};

const jsonData = JSON.stringify(persona); // Convierte objeto JS a JSON

console.log(jsonData);
// Resultado: '{"nombre":"Mar√≠a","edad":30,"ciudad":"Madrid"}'
```

## 4Ô∏è‚É£ JSON con Arrays y Objetos Anidados

Los valores en JSON pueden ser objetos anidados o arreglos.

```js
{
  "usuario": {
    "nombre": "Carlos",
    "email": "carlos@email.com"
  },
  "hobbies": ["f√∫tbol", "lectura", "videojuegos"]
}
```

En JavaScript

```js
const data = `{
  "usuario": {
    "nombre": "Carlos",
    "email": "carlos@email.com"
  },
  "hobbies": ["f√∫tbol", "lectura", "videojuegos"]
}`;

const obj = JSON.parse(data);
console.log(obj.usuario.nombre); // "Carlos"
console.log(obj.hobbies[1]); // "lectura"
```

## üí° Resumen Final

- ‚úîÔ∏è JSON es un formato de intercambio de datos basado en texto.
- ‚úîÔ∏è Usa {} para objetos y [] para listas o arreglos.
- ‚úîÔ∏è JSON.parse() convierte JSON en un objeto de JavaScript.
- ‚úîÔ∏è JSON.stringify() convierte un objeto de JavaScript en JSON.

---

# Web API's

Las Web APIs (Application Programming Interfaces) en JavaScript son conjuntos de funciones y 
herramientas que los navegadores web proporcionan para que los desarrolladores puedan interactuar 
con diferentes caracter√≠sticas del navegador y del sistema.

En otras palabras, son funciones ya creadas que JavaScript puede usar para hacer tareas como:
‚úîÔ∏è Manipular el DOM (Document Object Model).
‚úîÔ∏è Hacer peticiones HTTP a servidores.
‚úîÔ∏è Guardar datos en el navegador.
‚úîÔ∏è Acceder a dispositivos como la c√°mara o el micr√≥fono.

## 1. API del DOM

**¬øQu√© es?**
El DOM (Document Object Model) es la representaci√≥n estructural del contenido HTML de una p√°gina web. La API 
del DOM permite acceder, modificar y manipular esta estructura, lo que es fundamental para crear interactividad.

```js
// Modificar el contenido de un elemento: Seleccionamos el elemento con id "miElemento" y cambiamos su contenido
document.getElementById("miElemento").innerText = "¬°Hola, mundo!";

// Cambiar estilos din√°micamente: Al hacer clic en el bot√≥n, cambiaremos su color de fondo
document.getElementById("miBoton").addEventListener("click", function() {
    this.style.backgroundColor = "blue";
});
```

**Uso real:**
Imagina que tienes una lista de tareas y quieres actualizarla sin recargar la p√°gina. Usar√≠as el DOM API 
para agregar o eliminar elementos de la lista conforme el usuario interact√∫a con la aplicaci√≥n.

## 2. Fetch API

**¬øQu√© es?**
La Fetch API es la herramienta moderna para realizar peticiones HTTP desde el navegador. Permite 
comunicarse con servidores, obteniendo o enviando datos sin necesidad de recargar la p√°gina, 
utilizando promesas para gestionar las respuestas.

```js
fetch("https://jsonplaceholder.typicode.com/users")
  .then(response => response.json()) // Convertimos la respuesta a formato JSON
  .then(data => console.log(data))   // Mostramos los datos en consola
  .catch(error => console.error("Error:", error)); // Manejamos posibles errores
```

**Uso real:**
Puedes usarla para mostrar informaci√≥n actualizada en una aplicaci√≥n de noticias, un panel 
de control o cualquier sistema que necesite datos en tiempo real.

## 3. Storage API: LocalStorage y SessionStorage

**¬øQu√© son?**
Estas APIs permiten almacenar datos en el navegador sin necesidad de un servidor.
- LocalStorage: Almacena datos de forma persistente, es decir, la informaci√≥n se mantiene incluso despu√©s 
de cerrar el navegador.
- SessionStorage: Guarda datos solo durante la sesi√≥n actual; al cerrar la pesta√±a o el navegador, los datos se eliminan.

```js
// Guardamos un dato en localStorage
localStorage.setItem("usuario", "Carlos");

// Recuperamos el dato almacenado
console.log(localStorage.getItem("usuario"));
```

**Uso real:**
Ideal para guardar configuraciones del usuario, como preferencias de tema (oscuro/claro) o 
informaci√≥n de formularios, sin necesidad de conectarse a una base de datos.

## 4. Geolocation API

**¬øQu√© es?**
Esta API permite acceder a la ubicaci√≥n geogr√°fica del usuario, siempre y cuando √©ste otorgue el permiso. 
Es muy √∫til para aplicaciones basadas en mapas, servicios de ubicaci√≥n o aplicaciones del clima.

```js
navigator.geolocation.getCurrentPosition(position => {
  console.log("Latitud:", position.coords.latitude);
  console.log("Longitud:", position.coords.longitude);
});
```

**Uso real:**
Una aplicaci√≥n de delivery o de recomendaciones locales puede usar la Geolocation API 
para personalizar la experiencia del usuario seg√∫n su ubicaci√≥n.

## 5. Notification API

**¬øQu√© es?**
La Notification API permite enviar notificaciones al usuario directamente desde el navegador. 
Esto es especialmente √∫til para alertar sobre eventos importantes o actualizaciones, 
incluso cuando el usuario no est√° en la pesta√±a de la aplicaci√≥n.

```js
// Verificamos si ya se tiene permiso para mostrar notificaciones
if (Notification.permission === "granted") {
  new Notification("¬°Hola! Tienes una nueva notificaci√≥n.");
} else {
  // Si no se ha concedido el permiso, lo solicitamos
  Notification.requestPermission()
  .then(permission => {
    if (permission === "granted") {
      new Notification("¬°Gracias! Ahora recibir√°s notificaciones.");
    }
  });
}
```

**Uso real:**
Ideal para aplicaciones de mensajer√≠a, recordatorios de eventos o cualquier sistema 
que requiera mantener al usuario informado en tiempo real.

## 6. Clipboard API

**¬øQu√© es?**
Esta API permite interactuar con el portapapeles del sistema, lo que facilita 
copiar o pegar texto de manera program√°tica.

```js
navigator.clipboard.writeText("Texto copiado al portapapeles")
  .then(() => console.log("Texto copiado correctamente"))
  .catch(err => console.error("Error al copiar:", err));
```

**Uso real:**
√ötil en aplicaciones donde se desee facilitar la copia de enlaces, c√≥digos de descuento o 
informaci√≥n importante sin que el usuario tenga que hacerlo manualmente.

## 7. BOM (Browser Object Model)

**¬øQu√© es?**
El BOM (Browser Object Model) es un conjunto de objetos que permiten interactuar con el navegador. A diferencia del DOM, que solo maneja el contenido HTML, el BOM permite acceder a cosas como:

* ‚úîÔ∏è La URL actual.
* ‚úîÔ∏è Las ventanas y pesta√±as del navegador.
* ‚úîÔ∏è La consola y los alertas.
* ‚úîÔ∏è El historial de navegaci√≥n.
* ‚úîÔ∏è La informaci√≥n sobre la pantalla y el dispositivo.

**üí° Ejemplos pr√°cticos del BOM**

- **window** (El objeto principal del BOM): Todo en el BOM est√° dentro del objeto window, 
que representa la ventana del navegador.

```js
// üìå Ejemplo: Mostrar una alerta en pantalla
window.alert("¬°Hola! Esta es una alerta del BOM.");
// üìå Ejemplo: Obtener el ancho y alto de la ventana
console.log("Ancho de la ventana:", window.innerWidth);
console.log("Alto de la ventana:", window.innerHeight);
```

- **location** (Informaci√≥n de la URL actual): El objeto window.location te permite obtener 
informaci√≥n sobre la URL y modificarla.

```js
// üìå Ejemplo: Ver la URL actual
console.log("URL actual:", window.location.href);
// üìå Ejemplo: Redirigir a otra p√°gina
window.location.href = "https://www.google.com";
// üìå Ejemplo: Recargar la p√°gina
window.location.reload();
```

- **history** (Historial de navegaci√≥n): El objeto window.history permite interactuar con el historial del navegador.

```js
// üìå Ejemplo: Volver a la p√°gina anterior
window.history.back();
// üìå Ejemplo: Ir a la p√°gina siguiente
window.history.forward();
// üìå Ejemplo: Ir dos p√°ginas atr√°s en el historial
window.history.go(-2);
```

- **navigator** (Informaci√≥n del navegador y el dispositivo): El objeto window.navigator permite 
obtener informaci√≥n sobre el navegador, el sistema operativo y la conexi√≥n del usuario.

```js
// üìå Ejemplo: Saber qu√© navegador usa el usuario
console.log("Navegador:", window.navigator.userAgent);
// üìå Ejemplo: Saber si el usuario est√° en l√≠nea o no
console.log("¬øEst√° en l√≠nea?", window.navigator.onLine);
// üìå Ejemplo: Saber el idioma del navegador
console.log("Idioma del navegador:", window.navigator.language);
```

# 8. CSSOM (CSS Object Model)

**¬øQu√© es?**
El CSSOM (CSS Object Model) es similar al DOM, pero en lugar de manejar el contenido HTML, 
se usa para interactuar y modificar los estilos CSS de una p√°gina.

- **Modificar estilos** con `style`: Puedes cambiar los estilos de un elemento din√°micamente usando .style.

```js
// üìå Ejemplo: Cambiar el color de fondo de un bot√≥n
document.getElementById("miBoton").style.backgroundColor = "blue";
// üìå Ejemplo: Ocultar un elemento
document.getElementById("miElemento").style.display = "none";
// üìå Ejemplo: Cambiar el tama√±o de la fuente de un p√°rrafo
document.getElementById("miTexto").style.fontSize = "20px";
```

- **Obtener estilos calculados** con `getComputedStyle`: A veces, los estilos CSS est√°n en una hoja de 
estilos externa y no en style. Para obtenerlos, usamos getComputedStyle.

```js
// üìå Ejemplo: Saber el color de un bot√≥n
let boton = document.getElementById("miBoton");
let estilos = window.getComputedStyle(boton);
console.log("Color del bot√≥n:", estilos.backgroundColor);
```

- **Agregar o quitar clases** con `classList`: Otra forma eficiente de manejar estilos es usando 
clases CSS en lugar de modificar style directamente.

```js
// üìå Ejemplo: Agregar y quitar clases din√°micamente
document.getElementById("miCaja").classList.add("activo");  // Agregar una clase
document.getElementById("miCaja").classList.remove("activo"); // Quitar una clase
document.getElementById("miCaja").classList.toggle("activo"); // Alternar entre agregar/quitar
// üìå Ejemplo: Verificar si un elemento tiene una clase
let tieneClase = document.getElementById("miCaja").classList.contains("activo");
console.log("¬øTiene la clase activo?", tieneClase);
```

---

**Resumen Pr√°ctico**

- DOM API: Permite actualizar y modificar el contenido de la p√°gina, como cambiar 
textos, estilos o crear elementos nuevos.
- BOM permite interactuar con la ventana del navegador, la URL, el historial y la informaci√≥n del usuario.
- CSSOM permite modificar y obtener los estilos CSS de los elementos de la p√°gina.
- Fetch API: Facilita la comunicaci√≥n con servidores, permiti√©ndote obtener datos 
en tiempo real y actualizar la interfaz sin recargar la p√°gina.
- Storage API: Te ayuda a guardar datos localmente en el navegador, ya sea de forma 
persistente (LocalStorage) o temporal (SessionStorage).
- Geolocation API: Ofrece la posibilidad de obtener la ubicaci√≥n del usuario, ideal 
para aplicaciones basadas en ubicaci√≥n.
- Notification API: Permite enviar alertas y notificaciones al usuario, mejorando la 
comunicaci√≥n en tiempo real.
- Clipboard API: Facilita operaciones con el portapapeles, mejorando la experiencia 
de copiar y pegar contenido.